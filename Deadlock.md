##1.执行100次，每次死锁后截图
![](http://i.imgur.com/XyJRlh4.png)
##2.产生死锁的4个必要条件
* 互斥 一个资源只能被一个进程占有
* 占有并等待 请求资源时，一直占有已拿到的资源
* 非阻塞 进程只有在执行完了才释放占有的资源
* 循环等待 多个进程间形成一个循环等待资源的关系
##3.上述程序产生死锁的解释
　　如1中的图可见，输出的信息”Inside A.last()”先或”Inside B.last()”先的都有，而且次数也是差不多。所以a.methodA(b)里的b.last() 和 b.methodB(a)里的a.last()执行的时间比较接近了。相当于彼此都在请求对方资源，而且同时发生。   
![](http://i.imgur.com/Gna3hHk.png)
　　在这个Java程序中，我们创建了一个DeadLock的类来进行实现，同时我们创建了另外两个类A、B，这两个类分别有两个synchronized的函数，其中一个是需要调用另外一函数的。
死锁的发生：  
　　创建一个新线程t，给t设置一个创建延时后执行a这个类的方法函数，这个方法函数调用b的last（）函数。  
　　在第二个线程中，执行b这个类的方法函数，这个方法函数调用a的last函数。
因为在一个类中只能有一个线程在执行操作，因而，当有两个线程想要调用一个类里的操作时就发生了死锁。即：A占用了A的methodA函数，想要B的last（）资源，而与此同时，B占用了B的methodB函数想要A的last（）资源。满足了占有且等待的条件。同时满足了：互斥（synchronized实现）、非抢占（Java的两个进程具有相同的优先级）、满足了占有且等待的条件、循环等待（A/B互相等待）。
##4.实验感想
我的.bash文件运行的时候也会一直"No such file or directory "我确定路径没有问题，而且网上说的文件格式问题也不存在，:set ff=unix 没有问题，后来是直接在终端输入  
for (( c=1; c<=100; c++))  do    echo "$c times";      java DeadLock;  done    
运行的。  
这次的实验也并不难理解，主要就是掌握死锁的4个条件，就能破坏其条件使产生死锁了。
